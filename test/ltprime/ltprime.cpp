
// Copyright Janusz Rupar 2012
//
// Distributed under the Boost Software License, Version 1.0. 
//
// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.


#include <vector>
#include <iostream>

#include <boost/mpl/assert.hpp>

#include <boost/mpl/for_each.hpp>

#include <boost/bind.hpp>

#define _COTAP_ERROR_CHECK_

#include "prime.hpp"
#include "ltprime.hpp"
#include "range_c_func.hpp"
#include "range_c_ex2.hpp"
#include "for_each_ex.hpp"


static unsigned int org[] = {
    2, 3, 5, 7, 
    13, 17, 23, 37, 43, 47, 53, 67, 73, 83, 97, 
    113, 137, 167, 173, 197, 223, 283, 313, 317, 337, 347, 353, 367, 373, 383, 397, 443, 467, 523, 547, 613, 617, 643, 647, 653, 673, 683, 743, 773, 797, 823, 853, 883, 937, 947, 953, 967, 983, 997, 
    1223, 1283, 1367, 1373, 1523, 1613, 1823, 1997, 2113, 2137, 2347, 2383, 2467, 2617, 2647, 2683, 2797, 2953, 3137, 3167, 3313, 3347, 3373, 3467, 3547, 3613, 3617, 3643, 3673, 3797, 3823, 3853, 3947, 3967, 4283, 4337, 4373, 4397, 4523, 4547, 4643, 4673, 4937, 4967, 5113, 5167, 5197, 5347, 5443, 5647, 5653, 5683, 5743, 5953, 6113, 6173, 6197, 6317, 6337, 6353, 6367, 6373, 6397, 6547, 6653, 6673, 6823, 6883, 6947, 6967, 6983, 6997, 7283, 7523, 7547, 7643, 7673, 7823, 7853, 7883
};

static void find_divider(int val)
{
    for(int x = 2; x < val; ++x)
    {
        if(val % x == 0)
        {
            std::cout << "value: " << val << " diver: " << x << std::endl;
            break;
        }
    }
}


int main(int argc, char** argv)
{
    typedef ltprime::has_zero<mpl::int_<103> >::type has0_103;
    typedef ltprime::has_zero<mpl::int_<113> >::type has0_113;
    typedef ltprime::has_zero<mpl::int_<127> >::type has0_127;
    typedef ltprime::has_zero<mpl::int_<1003> >::type has0_1003;
    typedef ltprime::has_zero<mpl::int_<1013> >::type has0_1013;
    typedef ltprime::has_zero<mpl::int_<1113> >::type has0_1113;

    BOOST_MPL_ASSERT_RELATION( has0_103::value, ==, true );
    BOOST_MPL_ASSERT_RELATION( has0_113::value, ==, false );
    BOOST_MPL_ASSERT_RELATION( has0_127::value, ==, false );
    BOOST_MPL_ASSERT_RELATION( has0_1003::value, ==, true );
    BOOST_MPL_ASSERT_RELATION( has0_1013::value, ==, true );
    BOOST_MPL_ASSERT_RELATION( has0_1113::value, ==, false );

    //typedef ltprime::is_trunc_prime< mpl::int_<103> >::type istrunc_103; // does not check if there are zeros
    typedef ltprime::is_trunc_prime< mpl::int_<113> >::type istrunc_113;
    typedef ltprime::is_trunc_prime< mpl::int_<127> >::type istrunc_127;
    //typedef ltprime::is_trunc_prime< mpl::int_<1003> >::type istrunc_1003;
    //typedef ltprime::is_trunc_prime< mpl::int_<1013> >::type istrunc_1013;
    typedef ltprime::is_trunc_prime< mpl::int_<1113> >::type istrunc_1113;
    typedef ltprime::is_trunc_prime< mpl::int_<1223> >::type istrunc_1223;

    //BOOST_MPL_ASSERT_RELATION( istrunc_103::value, ==, false );
    BOOST_MPL_ASSERT_RELATION( istrunc_113::value, ==, true );
    BOOST_MPL_ASSERT_RELATION( istrunc_127::value, ==, false );
    //BOOST_MPL_ASSERT_RELATION( istrunc_1003::value, ==, false );
    //BOOST_MPL_ASSERT_RELATION( istrunc_1013::value, ==, false );
    BOOST_MPL_ASSERT_RELATION( istrunc_1113::value, ==, true );// 1113 is not ltprime but 113 and 13 are because it checks truncated values only
    BOOST_MPL_ASSERT_RELATION( istrunc_1223::value, ==, true );

    typedef ltprime::is_ltprime< mpl::int_<103> >::type isltp_103;
    typedef ltprime::is_ltprime< mpl::int_<113> >::type isltp_113;
    typedef ltprime::is_ltprime< mpl::int_<1003> >::type isltp_1003;
    typedef ltprime::is_ltprime< mpl::int_<1013> >::type isltp_1013;
    typedef ltprime::is_ltprime< mpl::int_<1113> >::type isltp_1113;
    typedef ltprime::is_ltprime< mpl::int_<127> >::type isltp_127;
    
    BOOST_MPL_ASSERT_RELATION( isltp_103::value, ==, false );
    BOOST_MPL_ASSERT_RELATION( isltp_113::value, ==, true );
    BOOST_MPL_ASSERT_RELATION( isltp_1003::value, ==, false );
    BOOST_MPL_ASSERT_RELATION( isltp_1013::value, ==, false );
    BOOST_MPL_ASSERT_RELATION( isltp_1113::value, ==, false );
    BOOST_MPL_ASSERT_RELATION( isltp_127::value, ==, false );

    typedef mpl::range_c_ex< int, 3, 9, 2>::type rce;
    typedef mpl::next<rce::begin>::type rce_next;
    typedef mpl::next<rce_next>::type rce_next2;
    typedef mpl::prior<rce_next2>::type rce_prior;
    BOOST_MPL_ASSERT_RELATION( mpl::deref<rce::begin>::type::value, ==, 3 );
    BOOST_MPL_ASSERT_RELATION( mpl::deref<rce_next>::type::value, ==, 5 );
    BOOST_MPL_ASSERT_RELATION( mpl::deref<rce_next2>::type::value, ==, 7 );
    BOOST_MPL_ASSERT_RELATION( mpl::deref<rce_prior>::type::value, ==, 5 );
    typedef mpl::begin<rce>::type rce_begin;
    typedef mpl::end<rce>::type rce_end;
    BOOST_MPL_ASSERT_RELATION( mpl::deref<rce_begin>::type::value, ==, 3 );
    BOOST_MPL_ASSERT_RELATION( mpl::deref<rce_end>::type::value, ==, 9 );

    //std::vector<int> ltprimesVec;
    //mpl::for_each< rce, mpl::_ >(boost::bind(static_cast<void(std::vector<int>::*)(const int&)>(&std::vector<int>::push_back), &ltprimesVec, _1));

    typedef mpl::range_c_func<int, 3, 10, mpl::plus<mpl::_, mpl::int_<3> > >::type rcf;
    typedef mpl::next<rcf::begin>::type rcf_next;
    BOOST_MPL_ASSERT_RELATION( mpl::deref<rcf::begin>::type::value, ==, 3 );
    BOOST_MPL_ASSERT_RELATION( mpl::deref<rcf_next>::type::value, ==, 6 );
    typedef mpl::begin<rcf>::type rcf_begin;
    typedef mpl::end<rcf>::type rcf_end;
    BOOST_MPL_ASSERT_RELATION( mpl::deref<rcf_begin>::type::value, ==, 3 );
    BOOST_MPL_ASSERT_RELATION( mpl::deref<rcf_end>::type::value, ==, 10 );

    //mpl::for_each_ex< rcf, mpl::_ >(boost::bind(static_cast<void(std::vector<int>::*)(const int&)>(&std::vector<int>::push_back), &ltprimesVec, _1));


    typedef mpl::range_c_ex2<int, 13, 103, 4, mpl::minus<mpl::int_<10>, mpl::_ >, mpl::plus<mpl::_, mpl::_/*mpl::minus<mpl::int_<10>, mpl::_ >*/ > >::type rce2;
    BOOST_MPL_ASSERT_RELATION( mpl::deref<rce2::begin>::type::value, ==, 13 );
    typedef mpl::next<rce2::begin>::type rce2_next;
    BOOST_MPL_ASSERT_RELATION( mpl::deref<rce2_next>::type::value, ==, 17 );

    //mpl::for_each_ex< rce2, mpl::_ >(boost::bind(static_cast<void(std::vector<int>::*)(const int&)>(&std::vector<int>::push_back), &ltprimesVec, _1));

    typedef ltprime::ltprime_gen_c<int>::type ltprimes;

    std::vector<int> ltprimesVec(4);
    ltprimesVec[0] = 2;
    ltprimesVec[1] = 3;
    ltprimesVec[2] = 5;
    ltprimesVec[3] = 7;
    mpl::for_each< ltprimes, mpl::_ >(boost::bind(static_cast<void(std::vector<int>::*)(const int&)>(&std::vector<int>::push_back), &ltprimesVec, _1));

    
    int cnt = ltprimesVec.size();
    std::cout << "Number of left truncated prime numbers: " << cnt << std::endl;
    for(int y = 0; y < cnt; ++y)
    {
        if(org[y] != ltprimesVec[y])
        {
            std::cout << std::endl;
            std::cout << "Error!" << std::endl;
            std::cout << "element: " << y << std::endl;
            std::cout << "org[y]: " << org[y] << std::endl;
            std::cout << "tabprime[y]: " << ltprimesVec[y] << std::endl;
            find_divider(ltprimesVec[y]);
            break;
        }
        std::cout << ltprimesVec[y] << ", ";
    }
    std::cout << std::endl;
    
    return 0;
}

